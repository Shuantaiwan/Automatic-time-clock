#include <Wire.h>
#include <LiquidCrystal_PCF8574.h>
#include <ThreeWire.h>
#include <RtcDS1302.h>
ThreeWire myWire(9, 10, 8);
RtcDS1302<ThreeWire> Rtc(myWire);
LiquidCrystal_PCF8574 lcd(0x27);
const char custom[][8] PROGMEM = 
{                        
  { 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00 }, 
  { 0x18, 0x1C, 0x1E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F }, 
  { 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x0F, 0x07, 0x03 }, 
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F }, 
  { 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1E, 0x1C, 0x18 }, 
  { 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x1F, 0x1F }, 
  { 0x1F, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F }, 
  { 0x03, 0x07, 0x0F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F }  
};
const char bigChars[][8] PROGMEM = 
{
  { 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 
  { 0x05, 0x05, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00 }, 
  { 0x04, 0xFF, 0x04, 0xFF, 0x04, 0x01, 0xFF, 0x01 }, 
  { 0x08, 0xFF, 0x06, 0x07, 0xFF, 0x05, 0x00, 0x00 }, 
  { 0x01, 0x20, 0x04, 0x01, 0x04, 0x01, 0x20, 0x04 }, 
  { 0x08, 0x06, 0x02, 0x20, 0x03, 0x07, 0x02, 0x04 }, 
  { 0x05, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 
  { 0x08, 0x01, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00 }, 
  { 0x01, 0x02, 0x04, 0x05, 0x00, 0x00, 0x00, 0x00 }, 
  { 0x01, 0x04, 0x04, 0x01, 0x04, 0x01, 0x01, 0x04 }, 
  { 0x04, 0xFF, 0x04, 0x01, 0xFF, 0x01, 0x00, 0x00 }, 
  { 0x20, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x04, 0x04, 0x04, 0x20, 0x20, 0x20, 0x00, 0x00 }, 
  { 0x20, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 
  { 0x20, 0x20, 0x04, 0x01, 0x04, 0x01, 0x20, 0x20 }, 
  { 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x00 }, 
  { 0x01, 0x02, 0x20, 0x04, 0xFF, 0x04, 0x00, 0x00 }, 
  { 0x06, 0x06, 0x02, 0xFF, 0x07, 0x07, 0x00, 0x00 }, 
  { 0x01, 0x06, 0x02, 0x04, 0x07, 0x05, 0x00, 0x00 }, 
  { 0x03, 0x04, 0xFF, 0x20, 0x20, 0xFF, 0x00, 0x00 }, 
  { 0xFF, 0x06, 0x06, 0x07, 0x07, 0x05, 0x00, 0x00 }, 
  { 0x08, 0x06, 0x06, 0x03, 0x07, 0x05, 0x00, 0x00 }, 
  { 0x01, 0x01, 0x02, 0x20, 0x08, 0x20, 0x00, 0x00 }, 
  { 0x08, 0x06, 0x02, 0x03, 0x07, 0x05, 0x00, 0x00 }, 
  { 0x08, 0x06, 0x02, 0x07, 0x07, 0x05, 0x00, 0x00 }, 
  { 0xA5, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 
  { 0x04, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 
  { 0x20, 0x04, 0x01, 0x01, 0x01, 0x04, 0x00, 0x00 }, 
  { 0x04, 0x04, 0x04, 0x01, 0x01, 0x01, 0x00, 0x00 }, 
  { 0x01, 0x04, 0x20, 0x04, 0x01, 0x01, 0x00, 0x00 }, 
  { 0x01, 0x06, 0x02, 0x20, 0x07, 0x20, 0x00, 0x00 }, 
  { 0x08, 0x06, 0x02, 0x03, 0x04, 0x04, 0x00, 0x00 }, 
  { 0x08, 0x06, 0x02, 0xFF, 0x20, 0xFF, 0x00, 0x00 }, 
  { 0xFF, 0x06, 0x05, 0xFF, 0x07, 0x02, 0x00, 0x00 }, 
  { 0x08, 0x01, 0x01, 0x03, 0x04, 0x04, 0x00, 0x00 }, 
  { 0xFF, 0x01, 0x02, 0xFF, 0x04, 0x05, 0x00, 0x00 }, 
  { 0xFF, 0x06, 0x06, 0xFF, 0x07, 0x07, 0x00, 0x00 }, 
  { 0xFF, 0x06, 0x06, 0xFF, 0x20, 0x20, 0x00, 0x00 }, 
  { 0x08, 0x01, 0x01, 0x03, 0x04, 0x02, 0x00, 0x00 }, 
  { 0xFF, 0x04, 0xFF, 0xFF, 0x20, 0xFF, 0x00, 0x00 }, 
  { 0x01, 0xFF, 0x01, 0x04, 0xFF, 0x04, 0x00, 0x00 }, 
  { 0x20, 0x20, 0xFF, 0x04, 0x04, 0x05, 0x00, 0x00 }, 
  { 0xFF, 0x04, 0x05, 0xFF, 0x20, 0x02, 0x00, 0x00 }, 
  { 0xFF, 0x20, 0x20, 0xFF, 0x04, 0x04, 0x00, 0x00 }, 
  { 0x08, 0x03, 0x05, 0x02, 0xFF, 0x20, 0x20, 0xFF }, 
  { 0xFF, 0x02, 0x20, 0xFF, 0xFF, 0x20, 0x03, 0xFF }, 
  { 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x00 }, 
  { 0x08, 0x06, 0x02, 0xFF, 0x20, 0x20, 0x00, 0x00 }, 
  { 0x08, 0x01, 0x02, 0x20, 0x03, 0x04, 0xFF, 0x04 }, 
  { 0xFF, 0x06, 0x02, 0xFF, 0x20, 0x02, 0x00, 0x00 }, 
  { 0x08, 0x06, 0x06, 0x07, 0x07, 0x05, 0x00, 0x00 }, 
  { 0x01, 0xFF, 0x01, 0x20, 0xFF, 0x20, 0x00, 0x00 },  
  { 0xFF, 0x20, 0xFF, 0x03, 0x04, 0x05, 0x00, 0x00 }, 
  { 0x03, 0x20, 0x20, 0x05, 0x20, 0x02, 0x08, 0x20 }, 
  { 0xFF, 0x20, 0x20, 0xFF, 0x03, 0x08, 0x02, 0x05 }, 
  { 0x03, 0x04, 0x05, 0x08, 0x20, 0x02, 0x00, 0x00 }, 
  { 0x03, 0x04, 0x05, 0x20, 0xFF, 0x20, 0x00, 0x00 }, 
  { 0x01, 0x06, 0x05, 0x08, 0x07, 0x04, 0x00, 0x00 }, 
  { 0xFF, 0x01, 0xFF, 0x04, 0x00, 0x00, 0x00, 0x00 },
  { 0x01, 0x04, 0x20, 0x20, 0x20, 0x20, 0x01, 0x04 }, 
  { 0x01, 0xFF, 0x04, 0xFF, 0x00, 0x00, 0x00, 0x00 }, 
  { 0x08, 0x02, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00 }, 
  { 0x20, 0x20, 0x20, 0x04, 0x04, 0x04, 0x00, 0x00 }  
};
byte col, row, nb = 0, bc = 0;                           
byte bb[8];  

void setup ()
{
  Serial.begin(9600);
  lcd.begin(16, 2);  
  lcd.setBacklight(255); 
  for (nb = 0; nb < 8; nb++ ) 
  {                 
    for (bc = 0; bc < 8; bc++) bb[bc] = pgm_read_byte( &custom[nb][bc] );
    lcd.createChar ( nb + 1, bb );
  }

  lcd.clear(); 
  writeBigString("T2A 32", 0, 0); 
  delay(1000);
  Serial.print("compiled: ");
  Serial.print(__DATE__);
  Serial.println(__TIME__);
  Rtc.Begin();
  RtcDateTime compiled = RtcDateTime(__DATE__, __TIME__);
  printDateTime(compiled);
  Serial.println();
  if (!Rtc.IsDateTimeValid())
  {
    Serial.println("RTC lost confidence in the DateTime!");
    Rtc.SetDateTime(compiled);
  }
  if (Rtc.GetIsWriteProtected())
  {
    Serial.println("RTC was write protected, enabling writing now");
    Rtc.SetIsWriteProtected(false);
  }
  if (!Rtc.GetIsRunning())
  {
    Serial.println("RTC was not actively running, starting now");
    Rtc.SetIsRunning(true);
  }
  RtcDateTime now = Rtc.GetDateTime();
  if (now < compiled)
  {
    Serial.println("RTC is older than compile time!  (Updating DateTime)");
    Rtc.SetDateTime(compiled);
  }
  else if (now > compiled)
  {
    Serial.println("RTC is newer than compile time. (this is expected)");
  }
  else if (now == compiled)
  {
    Serial.println("RTC is the same as compile time! (not expected but all is fine)");
  }
  
}

void loop ()
{
  RtcDateTime now = Rtc.GetDateTime();

  printDateTime(now);
  Serial.println();
  if (!now.IsValid())
  {
    Serial.println("RTC lost confidence in the DateTime!");
  }

  lcd.clear(); 
  if(now.Hour()>11)
  {
    lcd.setCursor(0, 0);
    lcd.print("P");
    lcd.setCursor(0, 1);
    lcd.print("M");
  }
  else
  {
    lcd.setCursor(0, 0);
    lcd.print("A");
    lcd.setCursor(0, 1);
    lcd.print("M");
  }
  char datestring[10];
  snprintf_P(datestring,
             10,
             PSTR("%02u:%02u"),
             now.Hour(),
             now.Minute());

  writeBigString(datestring, 3, 0);

  delay(10000); 
}
#define countof(a) (sizeof(a) / sizeof(a[0]))  
void printDateTime(const RtcDateTime& dt)
{
  char datestring[20];
  snprintf_P(datestring,
             countof(datestring),
             PSTR("%02u/%02u/%04u %02u:%02u:%02u"),
             dt.Month(),
             dt.Day(),
             dt.Year(),
             dt.Hour(),
             dt.Minute(),
             dt.Second() );
  Serial.print(datestring);
}
int writeBigChar(char ch, byte x, byte y) {
  if (ch < ' ' || ch > '_') return 0;             
  nb = 0;                                          
  for (bc = 0; bc < 8; bc++) {
    bb[bc] = pgm_read_byte( &bigChars[ch - ' '][bc] ); 
    if (bb[bc] != 0) nb++;
  }

  bc = 0;
  for (row = y; row < y + 2; row++) {
    for (col = x; col < x + nb / 2; col++ ) {
      lcd.setCursor(col, row);                      
      lcd.write(bb[bc++]);                         
    }                    
  }
  return nb / 2 - 1;                                 
}

void writeBigString(char *str, byte x, byte y) {
  char c;
  while ((c = *str++))
    x += writeBigChar(c, x, y) + 1;
}


// ********************************************************************************** //
//                                      OPERATION ROUTINES
// ********************************************************************************** //
// FREERAM: Returns the number of bytes currently free in RAM
int freeRam(void) {
  extern int  __bss_end, *__brkval;
  int free_memory;
  if ((int)__brkval == 0) {
    free_memory = ((int)&free_memory) - ((int)&__bss_end);
  }
  else {
    free_memory = ((int)&free_memory) - ((int)__brkval);
  }
  return free_memory;
}
